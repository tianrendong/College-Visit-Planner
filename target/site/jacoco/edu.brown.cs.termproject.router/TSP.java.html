<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TSP.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">college-visit-planner</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.termproject.router</a> &gt; <span class="el_source">TSP.java</span></div><h1>TSP.java</h1><pre class="source lang-java linenums">package edu.brown.cs.termproject.router;

import com.google.maps.errors.ApiException;
import edu.brown.cs.termproject.graph.Edge;
import edu.brown.cs.termproject.graph.GenericEdge;
import edu.brown.cs.termproject.graph.GenericGraph;
import edu.brown.cs.termproject.graph.Graph;
import edu.brown.cs.termproject.graph.Vertex;
import edu.brown.cs.termproject.iotools.GoogleMapAPIManager;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Stack;

/**
 * The class for Traveling Salesman Problem algorithm.
 * @param &lt;V&gt; type that extends Vertex.
 * @param &lt;E&gt; type that extends Edge.
 */
public class TSP&lt;V extends Vertex, E extends Edge&lt;V&gt;&gt; {
  /**
   * Constructor for TSP.
   */
<span class="fc" id="L30">  public TSP() {</span>
<span class="fc" id="L31">  }</span>

  /**
   * Finds the route that visits all the Locatables in locations once.
   *
   * @param g complete CollegeGraph
   * @return List of Locatable in the optimal visiting order.
   * @throws InterruptedException when interrupted.
   * @throws ApiException when google maps api errored.
   * @throws IOException when errored.
   */
  public List&lt;V&gt; findRoute(Graph&lt;V, E&gt; g) throws InterruptedException, ApiException, IOException {
<span class="fc" id="L43">    Comparator&lt;E&gt; comp = new Comparator&lt;E&gt;() {</span>
      @Override
      public int compare(E o1, E o2) {
<span class="fc" id="L46">        return Double.compare(o1.getWeight(), o2.getWeight());</span>
      }
    };
<span class="fc bfc" id="L49" title="All 2 branches covered.">    if (g.getVertices().size() == 1) {</span>
<span class="fc" id="L50">      List&lt;V&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L51">      Set&lt;V&gt; verts = g.getVertices();</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">      for (V v : verts) {</span>
<span class="fc" id="L53">        list.add(v);</span>
<span class="fc" id="L54">      }</span>
<span class="fc" id="L55">      return list;</span>
    }
<span class="fc" id="L57">    Set&lt;E&gt; mst = MST.mst(g, comp);</span>
    // Generate MST
<span class="fc" id="L59">    GenericGraph&lt;V, E&gt; mstGraph = new GenericGraph&lt;&gt;(mst);</span>
<span class="fc" id="L60">    TSPGraph&lt;V, E&gt; tsp = new TSPGraph&lt;&gt;(mstGraph);</span>
    // Get the set of odd degree vertices from MST
    // &amp; form a minimum-weight perfect matching graph
    // Combine the edges of the MST with the minimum-weight
    // perfect matching graph
<span class="fc" id="L65">    Set&lt;GenericEdge&lt;V&gt;&gt; matches = tsp.perfectMatches();</span>
<span class="fc" id="L66">    GenericGraph&lt;V, GenericEdge&lt;V&gt;&gt; graph = new GenericGraph&lt;V, GenericEdge&lt;V&gt;&gt;(matches);</span>
<span class="fc" id="L67">    TSPGraph&lt;V, GenericEdge&lt;V&gt;&gt; tspMatches = new TSPGraph&lt;V, GenericEdge&lt;V&gt;&gt;(graph);</span>
<span class="fc" id="L68">    ArrayList&lt;GenericEdge&lt;V&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    for (GenericEdge e : matches) {</span>
<span class="fc" id="L70">      list.add(e);</span>
<span class="fc" id="L71">    }</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">    for (int i = 1; i &lt; matches.size(); i++) {</span>
<span class="fc" id="L73">      tspMatches.addEdge(list.get(i).getStart(), list.get(i).getEnd());</span>
    }
    // Form a Eulerian circuit
    // Skip repeated vertices to form a Hamiltonian circuit
<span class="fc" id="L77">    return tspMatches.createEulerCircuit();</span>
  }

  /**
   * Class representing a graph of TSP.
   * @param &lt;V&gt; type that extends Vertex.
   * @param &lt;E&gt; type that extends Edge.
   */
  private static final class TSPGraph&lt;V extends Vertex, E extends Edge&lt;V&gt;&gt; {
    private GenericGraph initGraph;
<span class="fc" id="L87">    private ArrayList&lt;V&gt; eulerianCircuit = new ArrayList&lt;&gt;();</span>
    private HashMap&lt;V, ArrayList&lt;V&gt;&gt; adj;
    private HashMap&lt;V, Boolean&gt; isVisited;

<span class="fc" id="L91">    private TSPGraph(GenericGraph&lt;V, E&gt; g) {</span>
<span class="fc" id="L92">      this.initGraph = g;</span>
<span class="fc" id="L93">      Set&lt;V&gt; verts = g.getVertices();</span>
<span class="fc" id="L94">      this.adj = new HashMap&lt;&gt;();</span>
<span class="fc" id="L95">      Set&lt;E&gt; edges = g.getEdges();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">      for (V v : verts) {</span>
<span class="fc" id="L97">        this.adj.put(v, new ArrayList&lt;V&gt;());</span>
<span class="fc" id="L98">      }</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">      for (E edge : edges) {</span>
<span class="fc" id="L100">        V start = edge.getStart();</span>
<span class="fc" id="L101">        V end = edge.getEnd();</span>
<span class="fc" id="L102">        ArrayList&lt;V&gt; curr1 = this.adj.get(start);</span>
<span class="fc" id="L103">        ArrayList&lt;V&gt; curr2 = this.adj.get(end);</span>
<span class="fc" id="L104">        curr1.add(end);</span>
<span class="fc" id="L105">        curr2.add(start);</span>
<span class="fc" id="L106">        this.adj.replace(start, curr1);</span>
<span class="fc" id="L107">        this.adj.replace(end, curr2);</span>
<span class="fc" id="L108">      }</span>
<span class="fc" id="L109">    }</span>

    private int numVertices() {
<span class="fc" id="L112">      return this.initGraph.getVertices().size();</span>
    }


    private List&lt;V&gt; getOddDegreeVertices() {
<span class="fc" id="L117">      Set&lt;V&gt; verts = this.initGraph.getVertices();</span>
<span class="fc" id="L118">      HashMap&lt;V, Integer&gt; numNeighbors = this.numNeighbors();</span>
<span class="fc" id="L119">      List&lt;V&gt; oddDegreeVertices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">      for (V v : verts) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (numNeighbors.get(v) % 2 == 1) {</span>
<span class="fc" id="L122">          oddDegreeVertices.add(v);</span>
        }
<span class="fc" id="L124">      }</span>
<span class="fc" id="L125">      return oddDegreeVertices;</span>
    }

    private HashMap&lt;V, Integer&gt; numNeighbors() {
<span class="fc" id="L129">      Set&lt;E&gt; edges = this.initGraph.getEdges();</span>
<span class="fc" id="L130">      int numVertices = this.numVertices();</span>
<span class="fc" id="L131">      HashMap&lt;V, Integer&gt; numNeighbors = new HashMap&lt;&gt;(numVertices);</span>
<span class="fc" id="L132">      Iterator&lt;E&gt; it = edges.iterator();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L134">        E next = it.next();</span>
<span class="fc" id="L135">        V src = next.getStart();</span>
<span class="fc" id="L136">        V dst = next.getEnd();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (numNeighbors.containsKey(src)) {</span>
<span class="fc" id="L138">          numNeighbors.replace(src, 1 + numNeighbors.get(src));</span>
        } else {
<span class="fc" id="L140">          numNeighbors.put(src, 1);</span>
        }
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (numNeighbors.containsKey(dst)) {</span>
<span class="fc" id="L143">          numNeighbors.replace(dst, 1 + numNeighbors.get(dst));</span>
        } else {
<span class="fc" id="L145">          numNeighbors.put(dst, 1);</span>
        }
<span class="fc" id="L147">      }</span>
<span class="fc" id="L148">      return numNeighbors;</span>
    }

    /**
     * Generates a graph where every vertex has an even degree.
     * First gets the set of odd degree vertices from MST
     * &amp; fors a minimum-weight perfect matching graph.
     * Then combines the edges of the MST with the minimum-weight
     * perfect matching graph
     * @return Set of edges representing perfect matching graph
     * @throws InterruptedException
     * @throws ApiException
     * @throws IOException
     */
    public Set&lt;GenericEdge&lt;V&gt;&gt; perfectMatches()
        throws InterruptedException, ApiException, IOException {
<span class="fc" id="L164">      ArrayList&lt;GenericEdge&lt;V&gt;&gt; newEdges = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L165">      List&lt;V&gt; odd = this.getOddDegreeVertices();</span>
<span class="fc" id="L166">      Set&lt;E&gt; mst = this.initGraph.getEdges();</span>
<span class="fc" id="L167">      ArrayList&lt;GenericEdge&lt;V&gt;&gt; newedges = findMatches(odd, newEdges);</span>
<span class="fc" id="L168">      Set&lt;GenericEdge&lt;V&gt;&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      for (GenericEdge&lt;V&gt; edge : newedges) {</span>
<span class="fc" id="L170">        result.add(edge);</span>
<span class="fc" id="L171">      }</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      for (E edge : mst) {</span>
<span class="fc" id="L173">        GenericEdge&lt;V&gt; e = new GenericEdge(edge.getStart(), edge.getEnd(), edge.getWeight());</span>
<span class="fc" id="L174">        result.add(e);</span>
<span class="fc" id="L175">      }</span>
<span class="fc" id="L176">      return result;</span>
    }

    private ArrayList&lt;GenericEdge&lt;V&gt;&gt; findMatches(
        List&lt;V&gt; oddDegreeVertices, ArrayList&lt;GenericEdge&lt;V&gt;&gt; newEdges)
        throws InterruptedException, ApiException, IOException {
<span class="fc" id="L182">      double distance = 0.0, min = Double.MAX_VALUE;</span>
<span class="fc" id="L183">      int nextIndex = 0, indexForRemove = 0;</span>
      GenericEdge&lt;V&gt; currEdge;
      V curr, curr2;
<span class="fc bfc" id="L186" title="All 2 branches covered.">      for (int i = 0; i &lt; oddDegreeVertices.size(); i = nextIndex) {</span>
<span class="fc" id="L187">        curr = oddDegreeVertices.get(i);</span>
<span class="fc" id="L188">        oddDegreeVertices.remove(i);</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (int k = 0; k &lt; oddDegreeVertices.size(); k++) {</span>
<span class="fc" id="L191">          curr2 = oddDegreeVertices.get(k);</span>

<span class="fc" id="L193">          distance = GoogleMapAPIManager.getTravelDistance(</span>
<span class="fc" id="L194">              curr.getLat(), curr.getLon(), curr2.getLat(), curr2.getLon());</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">          if (distance &lt; min) {</span>
<span class="fc" id="L197">            min = distance;</span>
<span class="fc" id="L198">            nextIndex = 0;</span>
<span class="fc" id="L199">            indexForRemove = k;</span>
          }
        }

<span class="fc" id="L203">        curr2 = oddDegreeVertices.get(indexForRemove);</span>
<span class="fc" id="L204">        currEdge = new GenericEdge&lt;V&gt;(curr, curr2, GoogleMapAPIManager.getTravelDistance(</span>
<span class="fc" id="L205">            curr.getLat(), curr.getLon(), curr2.getLat(), curr2.getLon()));</span>
<span class="fc" id="L206">        newEdges.add(currEdge);</span>

<span class="fc" id="L208">        min = Integer.MAX_VALUE;</span>
<span class="fc" id="L209">        oddDegreeVertices.remove(indexForRemove);</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (oddDegreeVertices.size() == 2) {</span>
<span class="fc" id="L212">          V one = oddDegreeVertices.get(0);</span>
<span class="fc" id="L213">          V two = oddDegreeVertices.get(1);</span>
<span class="fc" id="L214">          currEdge = new GenericEdge(one, two, GoogleMapAPIManager.getTravelDistance(</span>
<span class="fc" id="L215">              one.getLat(), one.getLon(), two.getLat(), two.getLon()));</span>
<span class="fc" id="L216">          newEdges.add(currEdge);</span>
<span class="fc" id="L217">          break;</span>
        }
      }
<span class="fc" id="L220">      return newEdges;</span>
    }

    private void removeEdge(V u, V v) {
<span class="fc" id="L224">      ArrayList&lt;V&gt; arr = adj.get(u);</span>
<span class="fc" id="L225">      arr.remove(v);</span>
<span class="fc" id="L226">      adj.replace(u, arr);</span>
<span class="fc" id="L227">      ArrayList&lt;V&gt; arr2 = adj.get(v);</span>
<span class="fc" id="L228">      arr2.remove(u);</span>
<span class="fc" id="L229">      adj.replace(v, arr2);</span>
<span class="fc" id="L230">    }</span>

    private void addEdge(V u, V v) {
<span class="fc" id="L233">      ArrayList&lt;V&gt; arr = adj.get(u);</span>
<span class="fc" id="L234">      arr.add(v);</span>
<span class="fc" id="L235">      adj.replace(u, arr);</span>
<span class="fc" id="L236">      ArrayList&lt;V&gt; arr2 = adj.get(v);</span>
<span class="fc" id="L237">      arr2.add(u);</span>
<span class="fc" id="L238">      adj.replace(v, arr2);</span>
<span class="fc" id="L239">    }</span>

    /**
     * Creates a Eulerian circuit from
     * the existing graph. This visits every
     * edge once, but has repeat vertices
     * @return list of vertices
     */
    public ArrayList&lt;V&gt; createEulerCircuit() {
<span class="fc" id="L248">      HashMap&lt;V, Integer&gt; neighbors = this.numNeighbors();</span>
<span class="fc" id="L249">      V firstOdd = null;</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">      for (V key : neighbors.keySet()) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (adj.get(key).size() % 2 == 1) {</span>
<span class="fc" id="L252">          firstOdd = key;</span>
<span class="fc" id="L253">          break;</span>
        }
<span class="fc" id="L255">      }</span>
<span class="fc" id="L256">      this.eulerUtil(firstOdd);</span>
<span class="fc" id="L257">      ArrayList&lt;V&gt; result = this.clearRepeats();</span>
<span class="fc" id="L258">      return result;</span>
    }

    private void eulerUtil(V vert) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">      for (int i = 0; i &lt; this.adj.get(vert).size(); i++) {</span>
<span class="fc" id="L263">        V v = this.adj.get(vert).get(i);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (isValidNextEdge(vert, v)) {</span>
<span class="fc" id="L265">          this.eulerianCircuit.add(vert);</span>
<span class="fc" id="L266">          this.eulerianCircuit.add(v);</span>
<span class="fc" id="L267">          removeEdge(vert, v);</span>
<span class="fc" id="L268">          this.eulerUtil(v);</span>
        }
      }
<span class="fc" id="L271">    }</span>

    private boolean isValidNextEdge(V u, V v) {

<span class="fc bfc" id="L275" title="All 2 branches covered.">      if (this.adj.get(u).size() == 1) {</span>
<span class="fc" id="L276">        return true;</span>
      }
<span class="fc" id="L278">      this.isVisited = new HashMap&lt;V, Boolean&gt;();</span>
<span class="fc" id="L279">      int count1 = dfsCount(u);</span>
<span class="fc" id="L280">      this.removeEdge(u, v);</span>
<span class="fc" id="L281">      this.isVisited = new HashMap&lt;V, Boolean&gt;();</span>
<span class="fc" id="L282">      int count2 = dfsCount(u);</span>
<span class="fc" id="L283">      this.addEdge(u, v);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">      return (count1 &gt; count2) ? false : true;</span>
    }

    private int dfsCount(V s) {
<span class="fc" id="L288">      int count = 0;</span>
<span class="fc" id="L289">      Stack&lt;V&gt; stack = new Stack&lt;&gt;();</span>

<span class="fc" id="L291">      stack.push(s);</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">      while (!stack.empty()) {</span>
<span class="fc" id="L294">        s = stack.pop();</span>


<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (!this.isVisited.containsKey(s)) {</span>
<span class="fc" id="L298">          this.isVisited.put(s, true);</span>
<span class="fc" id="L299">          count++;</span>
        }

<span class="fc" id="L302">        Iterator&lt;V&gt; itr = adj.get(s).iterator();</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">        while (itr.hasNext()) {</span>
<span class="fc" id="L305">          V v = itr.next();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">          if (!this.isVisited.containsKey(v)) {</span>
<span class="fc" id="L307">            stack.push(v);</span>
          }
<span class="fc" id="L309">        }</span>
<span class="fc" id="L310">      }</span>
<span class="fc" id="L311">      return count;</span>
    }

    private ArrayList&lt;V&gt; clearRepeats() {
<span class="fc" id="L315">      ArrayList&lt;V&gt; verts = this.eulerianCircuit;</span>
<span class="fc" id="L316">      HashMap&lt;V, Integer&gt; vertsArray = new HashMap&lt;&gt;();</span>
<span class="fc" id="L317">      ArrayList&lt;V&gt; resultCircuit = new ArrayList&lt;V&gt;();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">      for (int i = 0; i &lt; verts.size(); i++) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (!vertsArray.containsKey(verts.get(i))) {</span>
<span class="fc" id="L320">          vertsArray.put(verts.get(i), 1);</span>
<span class="fc" id="L321">          resultCircuit.add(verts.get(i));</span>
        }
      }
<span class="fc" id="L324">      return resultCircuit;</span>
    }
  }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>